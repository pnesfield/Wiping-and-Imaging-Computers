Index
Part1 Wiping and Imaging Computers  - Overview and Capture of a Master Windows 10 Image using DISM

Part2 Wiping and Imaging Computers - Install Master Image and Add Drivers

Part3 Wiping and Imaging Computers  - Install Drivers

Part4 Wiping and Imaging Computers  - Add Drivers to WinPE

Part5 Wiping and Imaging Computers  - Add Drivers to WinPE boot.wim using DISM

Part6 Wiping and Imaging Computers  - Create a bootable USB with Diskpart

Part7 Wiping and Imaging Computers. Connect to Share in WinPE with Ethernet cable and wifi

Part8 Wiping and Imaging Computers. Create bootable USB (BIOS and UEFI) using Grub

Part9 Wiping and Imaging Computers. Grub bootable USB, add WinPE to menu for BIOS and UEFI modes

Part10 Wiping and Imaging Computers. Grub bootable USB, add themes

Part11 Wiping and Imaging Computers. Secure Boot with Grub and Microsoft USBs

Part12 Wiping and Imaging Computers. Making a disk unreadable, Encryption is the best solution.

Part13 Wiping and Imaging Computers. WinPE checking if the computer's disks are encrypted

Part14 Wiping and Imaging Computers. Imaging encrypted disks

Part15 Wiping and Imaging Computers. Wiping with hdparm on Linux

Part16 Wiping and Imaging Computers. Wiping using a bash script with hdparm

Part17 Wiping and Imaging Computers. Wiping using an enhanced bash script using whiptail dialogs

Part18 Wiping and Imaging Computers. Create a Linux PXE bootable image using debootstrap and chroot

Part19 Wiping and Imaging Computers. Configure chroot to run wipe scripts and boot from the USB

Part20 Wiping and Imaging Computers. Modifying a bootable .ISO file using xorriso

Part21 Wiping and Imaging Computers. Update Wipe script, writing a Splash Screen to an erased disk

Part22 Setup a dhcp network boot server - dhcp configuration

Part 23 Setup a tftp network boot server - tftp configuration

Part 24 Legacy/BIOS and UEFI network booting Grub

Part 25 Create a network bootable Linux PXE image to run wipe scripts

Part 26 Speeding Up the boot process

Part 27 Booting WinPE in UEFI with iPXE

Part 28 Install Windows in PXE from a Share

Part 29 Configure Routing with NAT for Linux Server

Part 30 Booting WinPE in Legacy BIOS with iPXE

Part 31 hyper-V Reference Images. Create PXE bootable VM in hyper-V

Part 32 Reference Images. Create linux based Hyper-V boot server with DHCP and TFTP

Part 33 Create Virtual Machines as Reference machines, capture wim file with DISM from vhdx file



Part1 Wiping and Imaging Computers  - Overview and Capture of a Master Windows 10 Image using DISM
=======================================================================================
Capturing a complete and up-to-date Windows 10 image that will be used later to image systems duplicating the Master image.
Uses WinPE (Pre-execution Environment) and Microsoft DISM (Deployment Imaging and Servicing Manager)

Capture.cmd
--------------------
:: Capture master image in install.wim
@echo off
set im=Windows10-x64-tt Pro
dism /image:d:\ /get-currentedition
set /P "image_ok=Is this the %im% image you want to capture Y/N "
if "%image_ok%"=="" goto EXIT
if /I not "%image_ok%"=="Y" goto EXIT
for /F "tokens=1" %%i in ('date /t') do set today=%%i
for /F "tokens=1" %%i in (version.txt) do set dir=%%i
:: echo Current Version %version%
SET version=%dir:~-1%
if %version% == 1 (
    SET dev_version=2
) else if %version% == 2 (
    SET dev_version=1
) else (
    echo Error image name suffix %version% must be a 1 or a 2  
)

SET dev_dir=%dir:~0,-1%%dev_version%
:: echo Dev Version %dev_dir%
time /t
echo on

dism /Capture-Image /imagefile:"%dev_dir%\install.wim" /CaptureDir:d:\ /Name:"%im%" /Description:"%im% %today%" 

time /t
dism /get-imageinfo /imagefile:"%dev_dir%\install.wim"
:EXIT

Append.cmd
--------------------
:: Append Master Image to install.wim
@echo off
dism /image:d:\ /get-currentedition
set /P "image_ok=Is this the Windows10-x64 Home image you want to capture Y/[N]"
if "%image_ok%"=="" goto EXIT
if /I not "%image_ok%"=="Y" goto EXIT
for /F "tokens=1" %%i in ('date /t') do set today=%%i
for /F "tokens=1" %%i in (version.txt) do set dir=%%i
:: echo Current Version %version%
SET version=%dir:~-1%
if %version% == 1 (
    SET dev_version=2
) else if %version% == 2 (
    SET dev_version=1
) else (
    echo Error image name suffix %version% must be a 1 or a 2  
)

SET dev_dir=%dir:~0,-1%%dev_version%
:: echo Dev Version %dev_dir%
dism /get-imageinfo /imagefile:"%dev_dir%\install.wim"
set /P "image_ok=Is this the Windows10-x64 Pro image you want to append Y/[N]"
if "%image_ok%"=="" goto EXIT
if /I not "%image_ok%"=="Y" goto EXIT
time /t
echo on

dism /Append-Image /imagefile:"%dev_dir%\install.wim" /CaptureDir:d:\ /Name:"Windows10-x64 Core" /Description:"Windows10-x64 Core %today%"  /ConfigFile:WimScript.ini
time /t
dism /get-imageinfo /imagefile:"%dev_dir%\install.wim"
:EXIT


Deploy.cmd
------------------
:: Switch current install.wim to a new one (without breaking anything)
:: version.txt has the current production version 1 or 2
echo off
for /F "tokens=1" %%i in (version.txt) do set dir=%%i
:: echo Current Version %version%
SET version=%dir:~-1%
if %version% == 1 (
    SET new_version=2
) else if %version% == 2 (
    SET new_version=1
) else (
    echo Error image name suffix %version% must be a 1 or a 2 
   
)

SET new_dir=%dir:~0,-1%%new_version%
:: echo Next Version %new_version%
echo Do you want to replace
dir %dir%\install.wim
echo with
echo.
dir %new_dir%\install.wim
set /P "image_ok=Are you sure Y/[N] "
if "%image_ok%"=="" goto EXIT
if /I not "%image_ok%"=="Y" goto EXIT
echo OK
echo %new_dir% [CHANGEME] version.txt
:EXIT
[CHANGEME] to greater than sign which is not allowed in youtube!!



Part2 Wiping and Imaging Computers - Install Master Image and Add Drivers
=========================================================================
Install the Master image captured in the previous part, and load any drivers that are required for the target system which may be different from the master.


Part3 Wiping and Imaging Computers  - Install Drivers
=====================================================
Windows Drivers, find them and make them available for subsequent installs


Part4 Wiping and Imaging Computers  - Add Drivers to WinPE
==========================================================
Check for missing drivers and make them available for subsequent installs



Part5 Wiping and Imaging Computers  - Add Drivers to WinPE boot.wim using DISM
==============================================================================
Find network drivers in Windows10, extract them and add them to the WinPE image in boot.wim using DISM. GetDrivers.ps1 finds and copies drivers ready for DISM. See the code below.

GetDrivers.ps1
===========
# Create directory of drivers missing in winre boot image from Windows 10 DriverStore
# 25/7/22 philn
$win10Inf =  "C:\Windows\INF\*.inf"
$win10Drivers = "C:\Windows\System32\DriverStore\FileRepository\"
$winreInfDir = "temp\Windows\INF" 
$drivers = "Drivers"
$files = Get-ChildItem $win10Inf
$numb = 0
$numb_new = 0
foreach ($f in $files){
    $outfile = $f.FullName
    foreach($line in Get-Content $f.FullName) {
      if($line -match "Class .*= Net$"){
        $winreInf = Split-Path $outfile -Leaf
        $winreInfFile = $winreInfDir + "\" + $winreInf
        if (-not (Test-Path $winreInfFile -PathType Leaf)) {
          $numb = $numb +1
          $winDriverName = (Get-Item $outfile ).Basename
          Write-Output("$numb $winDriverName  New Driver")
          # Copy-Item $f.FullName -Destination $drivers
          $driverDirs = $win10Drivers + $winDriverName + "*"
          if (-not (Test-Path $driverDirs -PathType Container)) {
            Write-Output("Error Cannot Find $driverDirs")dir dir 
            }
          else {
            $fullPath = Resolve-Path $driverDirs
            # Write-Output("Full path $fullPath")
            # Search for the dir with signed drivers
            foreach($driverDir in $fullPath) {
              $driverFiles = Get-ChildItem $driverDir  
              if (Test-Path -Path $driverDir\*.cat -PathType Leaf) {
                $numb_new = $numb_new + 1
                Write-Output("dir          $driverDir")
                foreach ($d in $driverFiles) {
                  Write-Output("Driver Files $d")
                  Copy-Item $d.FullName -Destination $drivers
                }
              }
              else {
                Write-Output("Not this one $driverDir")
              }
            }
            # break
          }
        }
      }
    }
    # if ($numb -gt 2) {Break}
}
Write-Output("Found $numb_new")

DISM add drivers to wim file
======================
mkdir temp
dism /mount-Image /imagefile:Winre.wim /index:1 /MountDir:temp 
dism /image:temp /Add-Driver:Drivers\ /recurse 
dism /unmount-image /mountdir:temp  /commit


Part6 Wiping and Imaging Computers  - Create a bootable USB with Diskpart
=========================================================================
Create a bootable USB with DISKPART
LIST DISK to find the USB drive
SELECT DISK
CLEAN to remove any residual partitions MBR
CREATE PARTITION PRIMARY SIZE=5120 this will be the boot partition with the Ebay image on it
SELECT PART 1
ACTIVE this makes the partition bootable 
FORMAT FS=FAT32 QUICK this allows both Legacy and UEFI to boot, but is limited in size and files cannot be bigger than 4Gbytes
ASSIGN creates a mount point and drive letter
EXIT
2. Restart DISPART to make a bigger NTFS partition for the TT image. Do not make this partition bootable
LIST DISK
SELECT DISK
CREATE PARTITION PRIMARY
SELECT PART 2
FORMAT FS=NTFS QUICK
ASSIGN
EXIT

:: Startnet for USB
:: November 2019 philn
@echo off
echo "Startnet Windows 10 USB -  version 1.1"
wpeinit
for %%a in (C D E F G H I) do @if exist %%a:\Sources\ set IMAGESDRIVE=%%a
:: echo Found %IMAGESDRIVE%
cd /d %IMAGESDRIVE%:\
:: pause
menu.cmd

:: Menu 
:: August 2022 philn
@echo off
echo.
echo ..................................
echo PXE Imaging Menu V1.0
echo ..................................
:MENU
set M=""
echo.
echo 1 - Win10-x64-TT - Install
echo 2 - Win10-x64 - Install
echo 3 - Check for Updated Install
echo 4 - Copy Updated Install
echo 5 - Exit to DOS
echo.
SET /P M=Type 1, 2, 3, 4 or 5 then press ENTER:  
if "%M%"=="" Goto G5
IF Not %M%==1 GOTO G2
echo Win10-x64-TT - Install
cd sources\win10-x64-tt
setup
cd \
goto MENU

:G2
if not %M%==2 goto G3
echo Win10-x64 - Install
cd sources\win10-x64
setup
cd \
goto MENU

:G3
if not %M%==3 goto G4
start /wait connect.cmd
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo Latest install timestamp
echo **************************************************
:: WinPE has no findstr
dir Y:\development\%dir%\install.wim
echo This install timestamp
echo **************************************************
dir images\win10-x64-tt\install.wim
echo Network Speed
wmic nic where netEnabled=true get name,speed,status
echo USB Type
wmic path CIM_USBDevice  get Name
echo Copy if speed is 1000000000 and USB 3.0
goto MENU

:G4
if not %M%==4 goto G5
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo time now %time%
:: del images\win10-x64-tt\install.wim
robocopy Y:\development\%dir% images\win10-x64-tt install.wim
goto MENU

:G5
echo Exit to DOS. To return to menu type MENU at DOS prompt
:EXIT


Part7 Wiping and Imaging Computers. Connect to Share in WinPE with Ethernet cable and wifi
======================================================================================
Modify Windows Recovery boot.wim to start WLAN wifi service, connect to a Wifi network and mount a Windows Share

Missing dlls in WinPE Recovery boot.wim
=================================
copy \Windows\System32\dmcmnutils.dll   temp\Windows\System32
copy \Windows\System32\mdmregistration.dll       temp\Windows\System32

Create WLAN profile
=================
netsh wlan export profile name="Murdoch" key=clear
copy Murdoch.xml temp\Windows\System32

Connect.cmd
===========
:: Connect to Window share
:: November 2019 philn
@echo off
echo "Connect Windows 10 -  version 3.2"
set server=192.168.0.1
echo Looking for server...
set /a counter=1
:LOOP1
echo Attempt %counter%
set /a counter+=1
ping %server%
if errorlevel 1 GOTO LOOP1
echo Found server
call wait 3
net stop ikeext
echo Mounting share...
net use Y: \\%server%\images$ /user:turing Ghana2009
if errorlevel 0 GOTO NEXT1
echo Failed to mount  \\%server%\images$
goto FINISH

:NEXT1
pause
Y:
:FINISH

Connect.2cmd
===========
:: Connect to Window share
:: November 2019 philn@echo off
@echo off
echo "Connect Windows 10 wifi -  version 3.2"
:: pnputil /add-driver D:\Usb_wifi\Drivers\*.inf /install
net start wlansvc
netsh wlan add profile filename=\Murdoch.xml
set server=192.168.10.54
ipconfig
:: pnputil /enum-devices /class net
echo Looking for server...
set /a counter=1
:LOOP1
echo Attempt %counter%
set /a counter+=1
ping %server%
call wait 3
if errorlevel 1 GOTO LOOP1
echo Found server
call wait 3
net stop ikeext
echo Mounting share...
net use Y: \\%server%\images$ /user:turing Ghana2009
if errorlevel 0 GOTO NEXT1
echo Failed to mount  \\%server%\images$
:NEXT1
pause
Y:
:FINISH

Wait.cmd
========
:: Alternative to pings which wait 1 second but tie up network
:: wait n
:: Wait for n seconds
:: November 2021 philn
@echo off
set sec=%time:~6,2%
:: set /A considers 09 as a bad Octal number, so remove leading 0s
::echo %sec~0,1% 
if "%sec:~0,1%" EQU "0" (set /A sec=%sec:~1,1%) else (set /A sec=%sec%)
set /A esec=sec + %1
::echo %sec%  now %esec%
set /A esec=esec%%60
::echo %esec% modulo
:wait
::echo now %sec%  end %esec% 
set sec=%time:~6,2%
if "%sec:~0,1%" EQU "0" (set /A sec=%sec:~1,1%) else (set /A sec=%sec%)
if %sec% neq %esec% goto wait


Part8 Wiping and Imaging Computers. Create bootable USB (BIOS and UEFI) using Grub
==================================================================================
On Windows, find and download a suitable iso that uses grub and boots BIOS and UEFI. Burn it to a USB with Rufus, with a FAT32 boot partition and the remainder of the space an NTFS partition for install files.
Use Diskmgr rather than diskpart to format the NTFS partition


Part9 Wiping and Imaging Computers. Grub bootable USB, add WinPE to menu for BIOS and UEFI modes
=====================================================================================
Use ntloader to boot a WinPE wim image in BIOS and UEFI mode.
boot.wim modified in Part 5 with startnet.cmd searching for a partition with sources on it containing the install files.

grub.cfg
=======
set timeout=-1

loadfont unicode

set menu_color_normal=white/black
set menu_color_highlight=black/light-gray

menuentry "Windows 10 ntloader Installers" {
    probe -s dev_uuid -u (hd0,1)
    if [ "$grub_platform" = "efi" ]; then
        echo "UEFI mode Grub - booting with ntloader"
 chainloader /ntloader/ntloader initrd=/ntloader/initrd.lz1 uuid=${dev_uuid} file=/winre/boot.wim
    else
        echo " "
        echo "BIOS mode Grub - booting with ntloader"
        linux16 /ntloader/ntloader  uuid=${dev_uuid} file=/winre/boot.wim
        initrd16 /ntloader/initrd.lz1
    fi
}

menuentry "Try or Install Ubuntu" {
 set gfxpayload=keep
 linux /casper/vmlinuz file=/cdrom/preseed/ubuntu.seed maybe-ubiquity quiet splash --- 
 initrd /casper/initrd
}
menuentry "Ubuntu (safe graphics)" {
 set gfxpayload=keep
 linux /casper/vmlinuz nomodeset file=/cdrom/preseed/ubuntu.seed maybe-ubiquity quiet splash --- 
 initrd /casper/initrd
}
menuentry "OEM install (for manufacturers)" {
 set gfxpayload=keep
 linux /casper/vmlinuz file=/cdrom/preseed/ubuntu.seed only-ubiquity oem-config/enable=true quiet splash --- 
 initrd /casper/initrd
}
grub_platform
if [ "$grub_platform" = "efi" ]; then
menuentry 'Boot from next volume' {
 exit 1
}
menuentry 'UEFI Firmware Settings' {
 fwsetup
}
else
menuentry 'Test memory' {
 linux16 /boot/memtest86+.bin
}
fi

boot.wim was modified in Part 5, uses startnet.cmd to find the \Sources\ directory and start menu.cmd. Note menu.cmd must be in the same partition as \Sources

startnet.cmd
==========
@echo off
echo "Startnet Windows 10 USB -  version 1.1"
wpeinit
for %%a in (C D E F G H I) do @if exist %%a:\Sources\ set IMAGESDRIVE=%%a
:: echo Found %IMAGESDRIVE%
cd /d %IMAGESDRIVE%:\
:: pause
menu.cmd


menu.cmd
=========
:: Menu for USB
@echo off
echo.
echo ..................................
echo Red Server - PXE Imaging Menu V1.3
echo ..................................
:MENU
set M=""
echo.
echo 1 - Win10-x64-TT - Install
echo 2 - Win10-x64 - Install
echo 3 - Check for Updated TT Install
echo 4 - Copy Updated TT Install
echo 5 - Review failed install logs
echo 6 - Exit to DOS
echo.
SET /P M=Type 1, 2, 3, 4, 5 or 6 then press ENTER:  
if "%M%"=="" Goto G6
IF Not %M%==1 GOTO G2
echo Win10-x64-TT - Install
cd sources\Win10-x64-tt
setup
cd \
goto MENU

:G2
if not %M%==2 goto G3
echo Win10-x64 - Install
cd sources\Win10-x64
setup
cd \
goto MENU

:G3
if not %M%==3 goto G4
start /wait connect.cmd
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo Latest install timestamp
echo **************************************************
:: WinPE has no findstr
dir Y:\development\%dir%\install.wim
echo This install timestamp
echo **************************************************
dir images\win10-x64-tt\install.wim
echo Network Speed
wmic nic where netEnabled=true get name,speed,status
echo USB Type
wmic path CIM_USBDevice  get Name
echo Copy if speed is 1000000000 and USB 3.0
goto MENU

:G4
if not %M%==4 goto G5
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo time now %time%
:: del images\win10-x64-tt\install.wim
robocopy Y:\development\%dir% images\win10-x64-tt install.wim
goto MENU

:G5
if not %M%==5 goto G6
start notepad X:\Windows\Panther\setupact.log
goto menu

:G6
echo Exit to DOS. To return to menu type MENU at DOS prompt
:EXIT


Part10 Wiping and Imaging Computers. Grub bootable USB, add themes
==================================================================
grub.cfg with theme added
grub.cfg
=======
set timeout=-1

loadfont unicode

set menu_color_normal=white/black
set menu_color_highlight=black/light-gray

loadfont unicode
insmod png
set gfxmode=auto
insmod efi_gop
insmod efi_uga
insmod gfxterm
insmod all_video
insmod gfxterm_background
terminal_output gfxterm
set theme=/boot/grub/themes/linuxmint/theme.txt  

menuentry "Windows 10 ntloader Installers" {
    probe -s dev_uuid -u (hd0,1)
    if [ "$grub_platform" = "efi" ]; then
        echo "UEFI mode Grub - booting with ntloader"
 chainloader /ntloader/ntloader initrd=/ntloader/initrd.lz1 uuid=${dev_uuid} file=/winre/boot.wim
    else
        echo " "
        echo "BIOS mode Grub - booting with ntloader"
        linux16 /ntloader/ntloader  uuid=${dev_uuid} file=/winre/boot.wim
        initrd16 /ntloader/initrd.lz1
    fi
}

menuentry "Try or Install Ubuntu" {
 set gfxpayload=keep
 linux /casper/vmlinuz file=/cdrom/preseed/ubuntu.seed maybe-ubiquity quiet splash --- 
 initrd /casper/initrd
}
menuentry "Ubuntu (safe graphics)" {
 set gfxpayload=keep
 linux /casper/vmlinuz nomodeset file=/cdrom/preseed/ubuntu.seed maybe-ubiquity quiet splash --- 
 initrd /casper/initrd
}
menuentry "OEM install (for manufacturers)" {
 set gfxpayload=keep
 linux /casper/vmlinuz file=/cdrom/preseed/ubuntu.seed only-ubiquity oem-config/enable=true quiet splash --- 
 initrd /casper/initrd
}
grub_platform
if [ "$grub_platform" = "efi" ]; then
menuentry 'Boot from next volume' {
 exit 1
}
menuentry 'UEFI Firmware Settings' {
 fwsetup
}
else
menuentry 'Test memory' {
 linux16 /boot/memtest86+.bin
}
fi

This is a minimalist theme based on linuxmint
theme.txt
========

title-text: "GRUB BIOS / UEFI USB Menu V1.1"
title-color: "#ffffff"
desktop-image: "lake.png"
desktop-color: "#000000"
terminal-box: "terminal_box_*.png"
terminal-left: "0"
terminal-top: "0"
terminal-width: "100%"
terminal-height: "100%"
terminal-border: "0"

# Boot menu
+ boot_menu {
  left = 5%
  top = 150
  width = 80%
  height = 60%
  item_color = "#ffffff"
  selected_item_color = "#ffffff"
  selected_item_pixmap_style = "select_*.png"
  item_height = 40
  item_spacing = 4
  item_pixmap_style = "item_*.png"
}

# Logo
#+ image {
#    top = 30
#    left = 50%-48
#    width = 100%
#    align = "center"
#    width = 96
#    height = 96
#    file = "logo.png"
#}

# Countdown message
#+ progress_bar {
#  left = 10%
#  top = 100%-60
#  width = 80%
#  align = "center"
#  id = "__timeout__"
#  text = "@TIMEOUT_NOTIFICATION_MIDDLE@"
 # color = "#ffffff"
#}

# Navigation keys hint c & e still work without this message
#+ label {
#  left = 0
#  top = 100%-24
#  width = 100%
#  align = "center"
#  text = "@KEYMAP_SHORT@"
#  color = "#DADADA"
#}

Part11 Wiping and Imaging Computers. Secure Boot with Grub and Microsoft USBs
=============================================================================
Secure Booting of Grub and Microsoft USBs made in Part 6 and Part 8


Part12 Wiping and Imaging Computers. Making a disk unreadable, Encryption is the best solution.
=====================================================================================
Turning on bitlocker.
System requirements: Windows 10 Pro, TPM 1.2 or later, compatible UEFI firmware
bitlocker error - An internal error was detected. Update BIOS
bitlocker error - This device cannot use a Trusted Platform Module. Enable TPM in the BIOS



Part13 Wiping and Imaging Computers. WinPE checking if the computer's disks are encrypted
===============================================================================
Using cscript in WinPE to check drive encryption status 

bitlocker.vbs
==========
strComputer = "."
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\CIMV2\Security\MicrosoftVolumeEncryption")
Set colItems = objWMIService.ExecQuery( _
    "SELECT * FROM Win32_EncryptableVolume",,48)
For Each objItem in colItems
    ' Wscript.Echo objItem.ProtectionStatus
    if (objItem.ProtectionStatus = 0) then
      enc = "bitlocker off"
    else
      enc = "bitlocker on"
    end if
    Wscript.Echo objItem.DriveLetter &   " " & enc
Next


menu.cmd
=========
:: Menu for USB
@echo off
:MENU
cls
echo.
echo ..................................
echo Red Server - PXE Imaging Menu V1.4
echo ..................................
set M=""
echo.
echo 1 - Win10-x64-TT - Install
echo 2 - Win10-x64 - Install
echo 3 - Check for Updated TT Install
echo 4 - Copy Updated TT Install
echo 5 - Review failed install logs
echo 6 - Check if discs are encrypted
echo 7 - Exit to DOS
echo.
SET /P M=Type 1, 2, 3, 4, 5, 6 or 7 then press ENTER:  
if "%M%"=="" Goto G6
IF Not %M%==1 GOTO G2
echo Win10-x64-TT - Install
cd sources\Win10-x64-tt
setup
cd \
goto MENU

:G2
if not %M%==2 goto G3
echo Win10-x64 - Install
cd sources\Win10-x64
setup
cd \
goto MENU

:G3
if not %M%==3 goto G4
start /wait connect.cmd
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo Latest install timestamp
echo **************************************************
:: WinPE has no findstr
dir Y:\development\%dir%\install.wim
echo This install timestamp
echo **************************************************
dir images\win10-x64-tt\install.wim
echo Network Speed
wmic nic where netEnabled=true get name,speed,status
echo USB Type
wmic path CIM_USBDevice  get Name
echo Copy if speed is 1000000000 and USB 3.0
goto MENU

:G4
if not %M%==4 goto G5
for /F "tokens=1" %%i in (Y:\development\version.txt) do set dir=%%i
echo time now %time%
:: del images\win10-x64-tt\install.wim
robocopy Y:\development\%dir% images\win10-x64-tt install.wim
goto MENU

:G5
if not %M%==5 goto G6
start notepad X:\Windows\Panther\setupact.log
goto menu

:G6
if not %M%==6 goto G7
cscript bitlocker.vbs
pause
goto menu

:G7
echo Exit to DOS. To return to menu type MENU at DOS prompt
:EXIT


Part14 Wiping and Imaging Computers. Imaging encrypted disks
============================================================
Imaging a disk encrypted with bitlocker.

Imaging a disk encrypted with WinMagic
- Use SecureDoc Recovery PSID revert to clear the disk


Part15 Wiping and Imaging Computers. Wiping with hdparm on Linux
================================================================
Installing Linux Mint from a USB as described in Part 8.
Other distros are available.
Install and use hdparm to secure-erase a disk

Part16 Wiping and Imaging Computers. Wiping using a bash script with hdparm
===========================================================================
A simple bash script to erase a disk using hdparm, demonstrating the steps required.
- Unfreeze the disk when frozen
- Set a password
- Use hdparm to use ATA commands to secure-erase or enhanced-secure-erase a disk, and clear the password

wipe2a.sh
========
In the script change [CHANGEME] to a greater than sign which is not allowed in youtube!!

#!/bin/bash
# Use secure erase or enhanced secure erase to wipe a disk
DEBUG=
DEV=$1
DEV="/dev/sdb"
  echo "Checking $DEV"
  lsblk -io TYPE,VENDOR,MODEL,SERIAL,SIZE $DEV | grep -v part
  HDTEST=`hdparm -I $DEV 2[CHANGEME]&1 | grep "SG_IO: bad/missing sense data" | awk '{print $1}'`
  if [ $HDTEST ]; then
    echo "Checking $DEV"
    echo "disk does not support secure erase"
    echo ""
    echo "- might be a RAID volume"
    echo "- might be an old disc"
    echo "- might be broken"
    sleep 2
    exit
  fi

  LOCK=`hdparm -I $DEV | grep locked | grep -c not`
  if [ $LOCK == 0 ]; then
    echo "disk is locked with a password"
    echo "Unlocking..."
    echo "hdparm --security-disable password --verbose $DEV"
    hdparm --security-disable password --verbose $DEV 
  else
    echo "disk is not Locked"
  fi

  DOIT=True
  while  [ "$DOIT" == "True" ]; do
    FROZEN=`hdparm -I $DEV | grep frozen | grep -c not`
    if [ $FROZEN == 0 ]; then
      echo "disk is frozen, System Sleep required"
      read -p "Continue Y[N]" ANS
      if [ "$ANS" == "Y" ]; then
        echo "sleep"
        rtcwake -u -s 10 -m mem
      else
        DOIT=
      fi
    else
      echo "disk is not frozen"
      DOIT=
    fi
  done
  ENHANCED_ERASE=`hdparm -I $DEV | grep -i enhanced | grep -c not`
  if [ $ENHANCED_ERASE == 0 ]; then
    # Inverse logic
    ERASE_TYPE="Enhanced Secure Erase" 
    ERASE_CMD="security-erase-enhanced"
  else
    ERASE_TYPE="Secure Erase"
    ERASE_CMD="security-erase"
  fi
  echo "disk supports $ERASE_TYPE"
  ERASE_TIME=`hdparm -I $DEV | grep -i "for security erase" | sed -e's/\t/ /g'`
  echo "disk estimated time to erase:"
  echo " $ERASE_TIME"
  if [ $ENHANCED_ERASE == 0 ]; then
    read -p "use enhanced erase Y[N]" ANS
    if [ "$ANS" != "Y" ]; then
      ERASE_TYPE="Secure Erase"
      ERASE_CMD="security-erase"
    fi
  fi

  echo "Setting password..."
  hdparm --security-set-pass password $DEV  [CHANGEME] /dev/null
  echo "disk Password set to password"
  MYTIMEVAR=`date +'%k:%M:%S'`
  echo "disk $ERASE_TYPE  started at $MYTIMEVAR"
  echo "Standby..."
  hdparm --$ERASE_CMD password $DEV [CHANGEME] /dev/null
  if [ $? -eq 0 ]; then
    MYTIMEVAR=`date +'%k:%M:%S'`
    echo "disk $ERASE_TYPE finished at $MYTIMEVAR" 
    echo
  else
    echo  "ER hdparm returned error: $?"
    echo -e "Erase failed. Check log"
  fi





Part17 Wiping and Imaging Computers. Wiping using an enhanced bash script using whiptail dialogs
================================================================================================
Using whiptail with bash to allow selection of drives to erase, choice of erasure by secure-erase or enhanced-secure-erase when available. Multiple drives handled by spawning and monitoring processes.

This is an enhancement of the bash script in Part16, using whiptail dialogs

wipe.sh
=======
In the script change [CHANGEME] to a greater than sign which is not allowed in youtube!!

#!/bin/bash
# Use secure erase or enhanced secure erase to wipe a disk
DEBUG=
version="1.3"
brand="Secure Erase $version"

drives=`lsblk -nio NAME,TYPE,TRAN,SIZE,MODEL | grep disk | grep -v usb | cut -f1 -d' '`
drives_count=0
echo "drives detected:"
for drive in $drives; do
  drives_count=$((drives_count+1))
  # MAKE=`lsblk -nio VENDOR /dev/$drive | awk '{print $1}'`
  MODEL=`lsblk -nio MODEL /dev/$drive | awk '{print $1}'`
  SIZE=`lsblk -nio SIZE,TYPE /dev/$drive | grep disk | awk '{print $1}'`
  # SERIAL=`lsblk -nio SERIAL /dev/$drive | awk '{print $1}'`
  drives_available+="/dev/$drive $MODEL,size_$SIZE    on "
  echo /dev/$drive
done
echo "number of drives $drives_count"
if [ $drives_count == 0 ]; then
  # No drives detected
  whiptail --title "$brand" --msgbox "No drives detected. Select Ok to exit." 22 78 12
  echo
  echo "Exiting........."
  sleep 2
  exit
else
  # Allow selection of drives to wipe
  drives_selected=$(whiptail --title "$brand" --checklist --separate-output "\n$drives_count drives are connected. \
The selected drives will be wiped in parallel." 22 78 12 $drives_available 3[CHANGEME]&1 1[CHANGEME]&2 2[CHANGEME]&3)

  exitstatus=$?
  if [[ ( $exitstatus != 0 ) || ( -z $drives_selected ) ]]; then
    whiptail --title "$brand" --msgbox "No drives selected. Select Ok to exit." 8 78
    echo "Exiting........."
    exit
  fi
  echo "drives selected:"
  echo "$drives_selected"
fi

SLEEP=False
for drive in $drives_selected; do
  echo "Checking $drive"
  lsblk -io TYPE,VENDOR,MODEL,SERIAL,SIZE $drive | grep -v part
  HDTEST=`hdparm -I $drive 2[CHANGEME]&1 | grep "SG_IO: bad/missing sense data" | awk '{print $1}'`
  if [ $HDTEST ]; then
    echo "Checking $DEV"
    echo "disk does not support secure erase"
    echo ""
    echo "- might be a RAID volume"
    echo "- might be an old disc"
    echo "- might be broken"
    sleep 2
    exit
  fi

  LOCK=`hdparm -I $drive | grep locked | grep -c not`
  if [ $LOCK == 0 ]; then
    echo "disk is locked with a password"
    echo "Unlocking..."
    echo "hdparm --security-disable password --verbose $DEV"
    hdparm --security-disable password --verbose $DEV 
  else
    echo "disk is not Locked"
  fi

  FROZEN=`hdparm -I $drive | grep frozen | grep -c not`
  if [ $FROZEN == 0 ]; then
    echo "disk is frozen, System Sleep required"
    SLEEP=True
  fi
done

if [ "$SLEEP" == "True" ]; then
  echo "Sleeping .."
  rtcwake -u -s 10 -m mem
fi

for drive in $drives_selected; do
  ENHANCED_ERASE=`hdparm -I $drive| grep -i enhanced | grep -c not`
  if [ $ENHANCED_ERASE == 0 ]; then
    # Inverse logic
    ERASE_TYPE="Enhanced Secure Erase" 
    ERASE_CMD="security-erase-enhanced"
  else
    ERASE_TYPE="Secure Erase"
    ERASE_CMD="security-erase"
  fi
  
  echo ""
  ERASE_TIME=`hdparm -I $drive | grep -i "for security erase" | sed -e's/\t/ /g'`
  echo "disk estimated time to erase:"
  echo " $ERASE_TIME"
  if [ $ENHANCED_ERASE == 0 ]; then
    MESS=`lsblk -nio TYPE,TRAN,SIZE,MODEL $drive  | grep -v part`
    if (whiptail --title "$brand" --yesno "$drive $MESS\ndisk supports $ERASE_TYPE\n
disk estimated time to erase:\n$ERASE_TIME\n\ndo you want to use $ERASE_TYPE" 20 78); then
      echo $ERASE_TYPE
    else
      ERASE_TYPE="Secure Erase"
      ERASE_CMD="security-erase"
    fi
  fi
  (./wipe_drive.sh $drive $ERASE_CMD &)
done

while true; do
  FINISHED=0
  clear
  for drive in $drives_selected; do
    CHECK=`ps -ef | grep -c "wipe_drive.sh $drive $ERASE_CMD"`  
    if [ $CHECK -ne 1 ]; then
      FINISHED=1
    fi
    logfile=`echo $drive | cut -f3 -d/`
    tail $logfile.log
    echo ""
  done
  if [ $FINISHED == 0 ]; then
      break
  fi
  sleep 2
done
echo "Finished"


Part18 Wiping and Imaging Computers. Create a Linux PXE bootable image using debootstrap and chroot
===================================================================================================
Setup a chroot image containing a minimal Linux OS to make it as small as possible - it will only be able to run bash scripts from a terminal. 

cat /etc/os-release
sudo apt-get install debootstrap
ls /usr/share/debootstrap/scripts

mkdir Image
cd Image
sudo debootstrap --arch=amd64 --variant=minbase focal chroot
sudo ./mount_for_chroot.sh
sudo chroot chroot

mount_for_chroot.sh
=================
#!/bin/bash
mount -v -t proc proc chroot/proc
mount -v -t sysfs sys chroot/sys
mount -v -o bind /dev chroot/dev
mount -v -o bind /dev/pts chroot/dev/pts

umount_for_chroot.sh
==================
#!/bin/bash
sudo umount chroot/proc
sudo umount chroot/sys
sudo umount chroot/dev/pts
sudo umount chroot/dev





Part19 Wiping and Imaging Computers. Configure chroot to run wipe scripts and boot from the USB
===============================================================================================
Create a PXE bootable image to allow any disk connected to the computer to be wiped.

Configure the chroot image to startup using /init, login as root and then run wipe scripts. 

Create an initrd file. Using the USB created in Part 8, modify the grub menu to boot a linux kernel and the new initrd

In the scripts change [CHANGEME1] to a greater than sign and [CHANGEME2] which are not allowed in youtube!!
 
setup.sh
=======
#!/bin/bash
export HOME=/root
export LC_ALL=C 
# This is done to use the simplest locale
echo "wiper"  {CHANGEME1} /etc/hostname
passwd -d root
# To reduce the amount of things installed by apt
cat {CHANGEME1}{CHANGEME1} /etc/apt/apt.conf {CHANGEME2}{CHANGEME2} EOF
APT::Install-Recommends "0"; 
APT::Install-Suggests "0";
APT::Get::Assume-Yes "1";
APT::Get::AllowUnauthenticated "1";
EOF

sed -i -e 's/$/ restricted universe multiverse/' /etc/apt/sources.list
apt-get update
cat /etc/apt/sources.list

apt-get install apt-utils
apt-get install linux-generic
apt-get install whiptail
apt-get install hdparm
apt-get install systemd
apt-get install init
apt-get install udev

sed -i -e 's/--noclear /--noclear --autologin root /' /lib/systemd/system/getty@.service

echo "./start.sh" {CHANGEME1}{CHANGEME1} /root/.bashrc

init
===
#!/bin/sh
. /etc/profile

init=/sbin/init
exec $init

start.sh
======
#!/bin/bash
export usb=""
while [ "$usb" == "" ] 
do
  sleep 2 
  export usb=`lsblk -nio NAME,TRAN | grep -i USB | cut -f1 -d' '`
  echo "Check for USB $usb"
done
part=1
mkdir /media/grub
echo mount /dev/$usb$part /media/grub
mount /dev/$usb$part /media/grub
cp /media/grub/wipe/*.sh .
cp /media/grub/wipe/*.iso .
umount /media/grub

./menu.sh

menu.sh
=======
#!/bin/bash
version=V1.0
title="Disk Wipe Utility $version"
export NEWT_COLORS='
window=white,black
border=white.black
textbox=white,black
button=white,red
'

while true; do

  selection=$(whiptail --title "$title" --menu "\nPlease select an option:\n " 22 78 12 \
  "Erase" "Run the Secure Erase script."\
  "Shell" "Run a bash shell." \
  "Shutdown" "Shutdown the machine." \
  "Reboot" "Reboot the machine." \
  "About" "Info about the wipe script" \
    3{CHANGEME1}&1 1{CHANGEME1}&2 2{CHANGEME1}&3);
  #"Wipe Advanced" "Run the wipe sript with advanced options."
    if [ "$selection" == "Erase" ]; then
      bash -c "./erase_script.sh"   
    elif [ "$selection" == "Shell" ]; then
        clear
        echo
        echo
        echo "Type exit to return to this menu."
        sleep 2
        bash --norc --noprofile
    elif [ "$selection" == "Shutdown" ]; then
        echo
        echo "Shutting down..."
        sleep 2
        shutdown -h 0
        exit
    elif [ "$selection" == "Reboot" ]; then
          echo
          echo "Rebooting..."
          sleep 2
          shutdown -r 0
          exit
    elif [ "$selection" == "About" ]; then        
      whiptail --title "Info" --msgbox "`cat about.txt`" 25 78 --scrolltext


    else
        echo "Selection " $selection
    sleep 2
    fi
done

erase_script.sh
============
 Is a renamed copy of wipe.sh in Part 17 

build.sh
======
#!/bin/bash
echo Move aside
mkdir aside
sudo mv chroot/var/lib/dpkg/ aside/dpkg
sudo mv chroot/var/lib/apt/ aside/apt
sudo mv chroot/var/cache/ aside/cache
sudo mv chroot/usr/share/doc/ aside/doc
sudo mv chroot/usr/share/man/ aside/man
sudo mv chroot/usr/src/ aside/src
sudo mv chroot/usr/lib/modules/5.4.0-26-generic/kernel/sound aside/sound
sudo mv chroot/usr/lib/modules/5.4.0-26-generic/kernel/net/wireless aside/wireless

cd chroot
sudo find . -print0 | sudo cpio --null -ov --format=newc | gzip -9 {CHANGEME1} ../initrd
cd ..
sudo mv aside/dpkg chroot/var/lib/
sudo mv aside/apt chroot/var/lib/
sudo mv aside/cache chroot/var/
sudo mv aside/doc chroot/usr/share/
sudo mv aside/man chroot/usr/share/
sudo mv aside/src chroot/usr/
sudo mv aside/sound chroot/usr/lib/modules/5.4.0-26-generic/kernel/
sudo mv aside/wireless chroot/usr/lib/modules/5.4.0-26-generic/kernel/net/
du -h initrd

grub.cfg
=======
menuentry "Secure Erase Disk Wipe Utility" {
 echo "Opening vmlinuz"
 linux /wipe/vmlinuz rootfstype=ramfs
    echo "Opening initrd"
    initrd /wipe/initrd
    echo "Unpacking"
}

Errata
In the video at 5.50 the linux kernel was copied, it should be moved to save space, as it is not used in initrd. /chroot/boot can and should be empty



Part20 Wiping and Imaging Computers. Modifying a bootable .ISO file using xorriso
=================================================================================
Modifying a bootable .ISO file, in this case ubuntu-22.04.1.iso using xorriso. Step 1 extract to an image. Step 2 delete, update and add files. Step 3 remake .ISO

Step1
=====
sudo apt-get install xorriso
xorriso -osirrox on -indev ubuntu-22.04.1-desktop-amd64.iso -extract / image

Step 2
grub.cfg
=======
set timeout=-1

loadfont unicode

set menu_color_normal=white/black
set menu_color_highlight=black/light-gray

insmod png
set gfxmode=auto
insmod efi_gop
insmod efi_uga
insmod gfxterm
insmod all_video
insmod gfxterm_background
terminal_output gfxterm
set theme=/boot/grub/themes/linuxmint/theme.txt  
set default=2

menuentry "Wiped: xxxx-xx-xx"{
true
}

menuentry "With: ttttttttttttttttttttt"{
true
}

menuentry "Reboot"{
reboot
}

theme.txt
========
# Global properties
title-text: ""
desktop-image: "background.png"
desktop-color: "#000000"

terminal-box: "terminal_box_*.png"
terminal-left: "0"
terminal-top: "0"
terminal-width: "100%"
terminal-height: "100%"
terminal-border: "0"

# Boot menu
+ boot_menu {
  left = 10%
  top = 150
  width = 80%
  height = 60%
  item_color = "#ffffff"
  selected_item_color = "#ffffff"
  item_height = 40
  item_spacing = 4
  item_pixmap_style = "item_*.png"
  selected_item_pixmap_style = "select_*.png"
}

Step3
Identify xorriso parameters
======================
xorriso -hfsplus on -indev ubuntu-22.04.1-desktop-amd64.iso -report_system_area as_mkisofs

Create .ISO
=========
xorriso -as mkisofs \
-V 'Splash' \
-o splash.iso \
--modification-date='2022081016214500' \
--grub2-mbr --interval:local_fs:0s-15s:zero_mbrpt,zero_gpt:'ubuntu-22.04.1-desktop-amd64.iso' \
--protective-msdos-label \
-partition_cyl_align off \
-partition_offset 16 \
--mbr-force-bootable \
-append_partition 2 28732ac11ff8d211ba4b00a0c93ec93b --interval:local_fs:7465120d-7473615d::'ubuntu-22.04.1-desktop-amd64.iso' \
-part_like_isohybrid \
-iso_mbr_part_type a2a0d0ebe5b9334487c068b6b72699c7 \
-c '/boot.catalog' \
-b '/boot/grub/i386-pc/eltorito.img' \
-no-emul-boot \
-boot-load-size 4 \
-boot-info-table \
--grub2-boot-info \
-eltorito-alt-boot \
-e '--interval:appended_partition_2_start_1866280s_size_8496d:all::' \
-no-emul-boot \
-boot-load-size 8496 \
-isohybrid-gpt-basdat \
image





Part21 Wiping and Imaging Computers. Update Wipe script, writing a Splash Screen to an erased disk
==================================================================================================
Updates to the wipe scripts to write a splash screen developed in Part 20 to the disk when erase has finished.

Change [CHANGEME1] to a greater than and [CHANGEME2] to a lesser than sign

disk_splash.sh
============
#!/bin/bash
# Update splash screen iso
drive=$1
logfile=$1.log
touch $logfile
TYPE=$2
# NVME Format ses 1
# Enhanced Secure Erase
# Secure Erase
# ttttttttttttttttttttt 
TYPE="$TYPE                      ."
STYPE=${TYPE:0:21}
echo Erase type 21 chars  [CHANGEME1][CHANGEME1] $logfile
echo " 123456789012345678901" [CHANGEME][CHANGEME] $logfile
echo "[CHANGEME1]$STYPE[CHANGEME2]" [CHANGEME]1[CHANGEME1] $logfile 
DATE=`date +%d/%m/%Y`
echo Date $DATE [CHANGEME1][CHANGEME1] $logfile
perl -pi -e "s#xxxx-xx-xx#$DATE#" splash.iso
perl -pi -e "s/ttttttttttttttttttttt/$STYPE/" splash.iso
echo "dd if=splash.iso of=/dev/$drive" [CHANGEME1][CHANGEME1] $logfile
dd if=splash.iso of=/dev/$drive [CHANGEME1][CHANGEME1] $logfile  2[CHANGEME1]&1

finish.sh
=======
#!/bin/bash
green='\033[0;32m'
off='\033[0;0m'
echo -e "${green}
.banner${off}"

wipe_drive.sh
===========
See Part 17

erase_script.sh
============
#!/bin/bash
# Use secure erase or enhanced secure erase to wipe a disk
DEBUG=
version="1.3"
brand="Secure Erase $version"
drives=`lsblk -nio NAME,TYPE,TRAN,SIZE,MODEL | grep disk | grep -v usb | cut -f1 -d' '`
drives_count=0
echo "drives detected:"
for drive in $drives; do
  drives_count=$((drives_count+1))
  # MAKE=`lsblk -nio VENDOR /dev/$drive | awk '{print $1}'`
  MODEL=`lsblk -nio MODEL /dev/$drive | awk '{print $1}'`
  SIZE=`lsblk -nio SIZE,TYPE /dev/$drive | grep disk | awk '{print $1}'`
  # SERIAL=`lsblk -nio SERIAL /dev/$drive | awk '{print $1}'`
  drives_available+="$drive $MODEL,size_$SIZE    on "
done
echo "number of drives $drives_count"
if [ $drives_count == 0 ]; then
  # No drives detected
  whiptail --title "$brand" --msgbox "No drives detected. Select Ok to exit." 22 78 12
  echo
  echo "Exiting........."
  sleep 2
  exit
else
  # Allow selection of drives to wipe
  drives_selected=$(whiptail --title "$brand" --checklist --separate-output "\n$drives_count drives are connected. \
The selected drives will be wiped in parallel." 22 78 12 $drives_available 3[CHANGEME1]&1 1[CHANGEME1]&2 2[CHANGEME1]&3)
  exitstatus=$?
  if [[ ( $exitstatus != 0 ) || ( -z $drives_selected ) ]]; then
    whiptail --title "$brand" --msgbox "No drives selected. Select Ok to exit." 8 78
    echo "Exiting........."
    exit
  fi
  echo "drives selected:"
  echo "$drives_selected"
fi
SLEEP=False
for drive in $drives_selected; do
  echo "Checking $drive"
  lsblk -io TYPE,VENDOR,MODEL,SERIAL,SIZE /dev/$drive | grep -v part
  HDTEST=`hdparm -I /dev/$drive 2[CHANGEME1]&1 | grep "SG_IO: bad/missing sense data" | awk '{print $1}'`
  if [ $HDTEST ]; then
    echo "Checking $drive"
    echo "disk does not support secure erase"
    echo ""
    echo "- might be a RAID volume"
    echo "- might be an old disc"
    echo "- might be broken"
    sleep 2
    exit
  fi
  LOCK=`hdparm -I /dev/$drive | grep locked | grep -c not`
  if [ $LOCK == 0 ]; then
    echo "disk is locked with a password"
    echo "Unlocking..."
    echo "hdparm --security-disable password --verbose /dev/$drive"
    hdparm --security-disable password --verbose /dev/$drive
  else
    echo "disk is not Locked"
  fi
  FROZEN=`hdparm -I /dev/$drive | grep frozen | grep -c not`
  if [ $FROZEN == 0 ]; then
    echo "disk is frozen, System Sleep required"
    SLEEP=True
  fi
done
if [ "$SLEEP" == "True" ]; then
  if (whiptail --title "$brand" --yesno "System must sleep to unfreeze the disk\n\ncontinue" 20 78); then
    echo "Sleeping .."
    rtcwake -u -s 10 -m mem
  else
    exit
  fi
fi
for drive in $drives_selected; do
  ENHANCED_ERASE=`hdparm -I /dev/$drive| grep -i enhanced | grep -c not`
  if [ $ENHANCED_ERASE == 0 ]; then
    # Inverse logic
    ERASE_TYPE="Enhanced Secure Erase" 
    ERASE_CMD="security-erase-enhanced"
  else
    ERASE_TYPE="Secure Erase"
    ERASE_CMD="security-erase"
  fi
  echo ""
  ERASE_TIME=`hdparm -I /dev/$drive | grep -i "for security erase" | sed -e's/\t/ /g'`
  echo "disk estimated time to erase:"
  echo " $ERASE_TIME"
  if [ $ENHANCED_ERASE == 0 ]; then
    MESS=`lsblk -nio TYPE,TRAN,SIZE,MODEL /dev/$drive  | grep -v part`
    if (whiptail --title "$brand" --yesno "$drive $MESS\ndisk supports $ERASE_TYPE\n
disk estimated time to erase:\n$ERASE_TIME\n\ndo you want to use $ERASE_TYPE" 20 78); then
      echo $ERASE_TYPE
    else
      ERASE_TYPE="Secure Erase"
      ERASE_CMD="security-erase"
    fi
  fi
  (./wipe_drive.sh $drive $ERASE_CMD &)
done
while true; do
  FINISHED=0
  clear
  for drive in $drives_selected; do
    CHECK=`ps -ef | grep -c "wipe_drive.sh $drive $ERASE_CMD"`  
    if [ $CHECK -ne 1 ]; then
      FINISHED=1
    fi
    logfile=`echo $drive | cut -f3 -d/`
    tail $logfile.log
    echo ""
  done
  if [ $FINISHED == 0 ]; then
      break
  fi
  sleep 2
done
./finish.sh
read -p "Continue ?" ANS
echo "Finished"




Part22 Setup a dhcp network boot server - dhcp configuration
============================================================

https://www.youtube.com/watch?v=Dn9y70VUNRU&t=2s

Set up a dhcp boot server for a network isolated from the company / office LAN. This will boot a client, provide a boot menu allowing the selection of wipe and install images for the PXE (Pre Execution Environment).

This part describes the dhcp server configuration.

Step 1
sudo apt-get install isc-dhcp-server

Step1 use ifconfig to identify the NIC for the wiping subnet

Step 2 Configure the Network Interface to use a fixed ip address of 192.168.0.1 (or something more suiatable

Step 3 Configure dhcp 
/etc/default/isc-dhcp-server
/etc/dhcp/dhcp.conf

Step 4 Restart
sudo service isc-dhcp-server start
sudo service isc-dhcp-server status


Part23 Setup a tftp network boot server - tftp configuration
============================================================

Set up a dhcp boot server for a network isolated from the company / office LAN. This will boot a client, provide a boot menu allowing the selection of wipe and install images for the PXE (Pre Execution Environment).

This part describes the tftp server configuration.

Step 1 Install a tftp server
sudo apt-get install tftpd-hpa

Step 2 Configure tftp server
tftpd-hpa

tftpd-remap.txt

Step 3 Install grub
sudo  apt-get install grub-efi-amd64-signed

Step 4 Configure grub
/var/server/grub/grub.cfg
/var/server/grub/themes/linuxmint/theme.txt

Step 5 Test UEFI boot into grub

Part 24 Legacy/BIOS and UEFI network booting Grub
=================================================
Configure a network boot server to PXE boot Grub in both Legacy/BIOS and UEFI modes.
Build Legacy/BIOS Grub image with grub-mkimage with custom configuration File 



Step 1 check grub is installed
sudo  apt-get install grub-efi-amd64-signed 



Step 2 make a legacy/BIOS grub image core.0
sudo grub-mkimage -O i386-pc-pxe \
    --output /var/server/grub/i386-pc/core.0 \
    --prefix=grub \
    -c grub-build.conf \
    -d /usr/lib/grub/i386-pc/  \
  pxe tftp 


grub-build.conf
============
set root=(tftp)
set net_default_server=192.168.0.1
set prefix=grub
# set debug=all 



Step 3 Configure dhcp.conf to use core.0
part of /etc/dhcp/dhcp.conf
=======================
# Red subnet.
subnet 192.168.0.0 netmask 255.255.255.0{
  range 192.168.0.10 192.168.0.254;
  option domain-name-servers 8.8.8.8, 8.8.4.4;
# option domain-name "internal.example.org";
  option subnet-mask 255.255.255.0;
  option routers 192.168.0.1;
  option broadcast-address 192.168.0.255;
  default-lease-time 600;
  max-lease-time 7200;
  filename "grub/i386-pc/core.0";
}

class "UEFI-64-1" {
  match if substring(option vendor-class-identifier, 15, 5) = "00007";
      filename "grub/grubnetx64.efi";
}


Step 4 Restart Service
sudo service isc-dhcp-server restart



Step 5 Test Legacy/BIOS network boot

Part 25 Create a network bootable Linux PXE image to run wipe scripts
=====================================================================
https://www.youtube.com/watch?v=xVrb9LZRX00

Copy and Modify the chroot image created in Parts 18 & 19, create a PXE bootable Linux image to boot from the network and start Wipe scripts developed in Parts 17 and 21

sudo ./mount_for_chroot.sh
sudo chroot chroot

Within chroot:
apt-get install atftp
apt-get install inetutils-ping

sudo ./umount_for_chroot.sh
exit

These scripts are also available from git
https://github.com/pnesfield/Wiping-and-Imaging-Computers

start.sh

mk_image.sh

/var/server/grub/grub.cfg

/var/server/grub/themes/linuxmint/theme.txt

/var/server/wipe
==============
Contains vmlinuz, initrd, copy_files.sh and all the wipe scripts from Part21 and Part17, and splash.iso made in Part20

copy_files.sh

cat /etc/os-release
sudo apt-get install debootstrap
ls /usr/share/debootstrap/scripts

mkdir Image
cd Image
sudo debootstrap --arch=amd64 --variant=minbase focal chroot

sudo ./mount_for_chroot.sh
sudo chroot chroot

apt-get -y install atftp
apt-get -y install inetutils-ping

sudo ./umount_for_chroot.sh

Part26 Speeding Up the boot process
===================================

https://www.youtube.com/watch?v=DwdUAAq9GGc

tftp is the default network protocol to copy the bootable image. Http speeds up the process by a factor of 4. This video shows how, and tries both Apache2 and Nginx. Nginx proved to be faster in this application.

apache2
=======
sudo apt-get -y install apache2 

/etc/apache2/apache2.conf
add:
<Directory /var/server/>
	Options Indexes FollowSymLinks
	AllowOverride None
	Require all granted
</Directory>

/etc/apache2/sites-enabled/000-default.conf
change line 12:
DocumentRoot /var/server

nginx
======
sudo apt-get -y install nginx

/etc/nginx/sites-enabled/default
change line 41:
	root /var/server;

tftp client
===========
apt-get -y install atftp


test_web.sh
===========
~/Server$ ./test_web.sh 
tftp

real	0m15.047s
user	0m1.891s
sys	0m8.812s
apache2
--2023-02-18 11:14:04--  http://192.168.0.1/wipe/initrd
Connecting to 192.168.0.1:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 344776695 (329M)
Saving to: ‘initrd’

initrd              100%[===================>] 328.80M   579MB/s    in 0.6s    

2023-02-18 11:14:05 (579 MB/s) - ‘initrd’ saved [344776695/344776695]


real	0m0.572s
user	0m0.080s
sys	0m0.490s
nginx
--2023-02-18 11:14:06--  http://192.168.0.1/wipe/initrd
Connecting to 192.168.0.1:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 344776695 (329M) [application/octet-stream]
Saving to: ‘initrd’

initrd              100%[===================>] 328.80M   661MB/s    in 0.5s    

2023-02-18 11:14:06 (661 MB/s) - ‘initrd’ saved [344776695/344776695]


real	0m0.501s
user	0m0.064s
sys	0m0.436s


Part27 Booting WinPE in UEFI with iPXE
======================================
Boot UEFI computer into WinPE which will be used to install Windows. Configure grub to chainload (replace itself with) iPXE, and then have IPXE use wimboot to boot WinPE (Windows PreExecution Environment) using boot.wim built in Part 5.

1. Configure grub
/var/server/grub/grub.cfg
=========================
menuentry 'Windows 10 Installers' {
if [ "$grub_platform" = "efi" ]; then
  echo "UEFI Grub opening ipxe.efi"
  chainloader /ipxe/ipxe.efi
fi

2. Setup IPXE
Download ipxe from github and build it
https://github.com/ipxe/ipxe

sudo apt-get install liblzma-dev

make bin-x86_64-efi/ipxe.efi 

3. Give the config / menu to IPXE 
/etc/dhcp/dhcpd.conf
====================
class "UEFI-64-1" {
  match if substring(option vendor-class-identifier, 15, 5) = "00007";
      filename "grub/grubnetx64.efi";
  if exists user-class and option user-class = "iPXE" {
      filename "ipxe/bootuefi.ipxe";
  }
}

sudo service isc-dhcp-server restart

4. Create the IPXE config file
/var/server/ipxe/bootuefi.ipxe
==============================
#!ipxe
  echo Booting wimboot
  kernel http://192.168.0.1/wimboot/wimboot
  initrd /wimboot/bcd
  initrd /wimboot/boot.sdi
  initrd --name startnet.cmd /winpe/startnet_uefi.cmd 
  initrd /winpe/wait.cmd
  initrd http://192.168.0.1/sources/boot.wim boot.wim
  boot

5. Download wimboot https://ipxe.org/wimboot

6. Create startnet
/var/server/winpe/startnet_uefi.cmd
===================================
@ECHO OFF
echo "Startnet Windows 10 PXE -  version 2.5"
wpeinit
echo Looking for server...
set /a counter=1
:LOOP1
echo Attempt %counter%
set /a counter+=1
ping 192.168.0.1
if errorlevel 1 GOTO LOOP1
echo Found server
call wait 3
net stop ikeext
call wait 1
cmd /c
pause

7. Create wait.cmd
/var/server/winpe/wait.cmd
==========================
:: Alternative to pings which wait 1 second but tie up network
:: wait n
:: Wait for n seconds
set sec=%time:~6,2%
:: set /A considers 09 as a bad Octal number, so remove leading 0s
::echo %sec~0,1% 
if "%sec:~0,1%" EQU "0" (set /A sec=%sec:~1,1%) else (set /A sec=%sec%)
set /A esec=sec + %1
::echo %sec%  now %esec%
set /A esec=esec%%60
::echo %esec% modulo
:wait
::echo now %sec%  end %esec% 
set sec=%time:~6,2%
if "%sec:~0,1%" EQU "0" (set /A sec=%sec:~1,1%) else (set /A sec=%sec%)
if %sec% neq %esec% goto wait

Boot it



Part 28 Install Windows in PXE from a Share
===========================================
In the previous part a computer was booted into WinPE. Now WinPE will connect to a share and run setup to install Windows.

The File Server can be Windows or Linux - the boot server. This shows how to build a Linux File Server using Samba

1. Install Samba
sudo apt-get -y install samba

2. Configure /etc/samba/smb.conf
#======================= Global Settings =======================

[global]
deadtime = 5
## Browsing/Identification ###

# Change this to the workgroup/NT-domain name your Samba server will part of
   workgroup = WORKGROUP

# server string is the equivalent of the NT Description field
   server string = %h server (Samba, Ubuntu)
   netbios name = redserver

#### Networking ####
....

# Only bind to the named interfaces and/or networks; you must use the
# 'interfaces' option above to use this.
# It is recommended that you enable this feature if your Samba machine is
# not protected by a firewall or is a firewall itself.  However, this
# option cannot handle dynamic or non-broadcast interfaces correctly.
   bind interfaces only = yes
   interfaces = lo eno1
....

#======================= Share Definitions =======================
[sources]
  Comment = WinPE Share
  path = /var/server/sources
  read only = yes
  browseable = yes
  guest ok = yes

3. Restart Samba
================
sudo service smbd restart

4. Setup scripts
================
startnet_uefi.cmd
=================
:: November 2019 philn
:: 4/12/19 Added ping to improve reliability of net use
:: 25/2/21 Added loop
:: 12/11/21 Added target
:: 12/11/21 Added stop ikeext which interferes with net use
:: 22/3/22 remove pause
:: 16/5/22 Added second wait before mounting the share
@ECHO OFF
echo "Startnet Windows 10 PXE -  version 2.5"
wpeinit
echo Looking for server...
set /a counter=1
:LOOP1
echo Attempt %counter%
set /a counter+=1
ping 192.168.0.1
if errorlevel 1 GOTO LOOP1
echo Found server
call wait 3
net stop ikeext
call wait 1
echo Mounting share...
net use Y: \\192.168.0.1\sources
if not errorlevel 1 GOTO NEXT1
echo Failed to mount  \\192.168.0.1\sources
echo try running startnet.cmd again
goto FINISH

:NEXT1
echo Done that
Y:
menu.cmd
:FINISH
cmd /c
pause

menu.cmd
========
@echo off
:MENU
cls
echo:
echo ..................................
echo Red Server - PXE Imaging Menu V1.5
echo ..................................
set IMAGESDRIVE=
for %%a in (C D E F G H I) do @if exist %%a:\Windows\ set IMAGESDRIVE=%%a
::echo Found %IMAGESDRIVE%
if not "%IMAGESDRIVE%" == "" (    
 diskpart /s diskpart.txt
 echo:
 echo Windows has been found on drive %IMAGESDRIVE%:
 echo This system may not have been wiped. Please Check.
)
set M=""
echo.
echo 1 - Win10-x64-TT - Install
echo 2 - Win10-x64-min - Install
echo 3 - Win10-x64 - Install
echo 4 - Review failed install logs
echo 5 - Exit to DOS
echo:
SET /P M=Type 1, 2, 3, 4 or 5 then press ENTER:  
IF Not %M%==1 GOTO G2
echo Win10-x64-TT - Install
for /F "tokens=1" %%i in (version-tt.txt) do set dir=%%i
cd %dir%
setup
cd ..
goto MENU

:G2
if not %M%==2 goto G3
echo Win10-x64 min - Install
for /F "tokens=1" %%i in (version-min.txt) do set dir=%%i
cd %dir%
setup
cd ..
goto MENU


:G3
if not %M%==3 goto G4
echo Win10-x64 - Install
cd Win10-x64
setup
cd ..
goto MENU

:G4
if not %M%==4 goto G5
start notepad X:\Windows\Panther\setupact.log
goto menu

:G5
if not %M%==5 goto MENU
echo Exit to DOS. 
echo To return to menu type MENU at DOS prompt
echo To reboot type Exit


version-min.txt
===============
win10-x64-min1













Part 29 Configure Routing with NAT for Linux Server
===================================================
During and after Windows10 installation, the computer will need to access the internet. This Part shows how to configure a Linux system as a router with iptables using NAT (Network Address Translation).

1. Edit sysctl.conf
/etc/sysctl.conf
================
# Uncomment the next line to enable packet forwarding for IPv4
net.ipv4.ip_forward=1

#net.ipv6.conf.all.forwarding = 1
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1

2. Check
sudo sysctl -p

cat  /proc/sys/net/ipv4/ip_forward

3. Check network Interfaces
ifconfig

4. Edit and Run Routing_Setup.sh
================================
#! /bin/bash
# Setup routing tables with NAT for clients on the 192.168.0.1 Red network
# change internet NIC from wlp2s0 as required (eg eno4)
# change Red Network NIC eno1 (eg bond0)
INT_DEV=wlp2s0
RED_DEV=eno1

iptables -t nat --flush 

iptables -t nat -A POSTROUTING -o $INT_DEV -j MASQUERADE

iptables --flush
iptables -A FORWARD -s 192.168.0.0/24 -p tcp --match multiport --dport 53,80,443 -j ACCEPT
iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT

iptables -A FORWARD -i $INT_DEV -o $RED_DEV -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables -A FORWARD -s 192.168.0.0/24 -p all -j DROP

iptables -t nat -v -L POSTROUTING --line-number
echo ""
echo ""
iptables -L -v

ip6tables -A INPUT  -p all -j DROP
ip6tables -A FORWARD  -p all -j DROP
ip6tables -A OUTPUT  -p all -j DROP
ip6tables -L


5. Save the iptables rules
==========================
sudo apt-get install iptables-persistent


Part 30 Booting WinPE in Legacy BIOS with iPXE
==============================================
Boot Legacy BIOS computer into WinPE which will be used to install Windows. Configure grub to load an iPXE kernel, and then have IPXE use wimboot to boot WinPE (Windows PreExecution Environment) using boot.wim built in Part 5.

1. Check dhcp
As setup in Part 24
/etc/dhcp/dhcpd.conf
boots into grub

2.Configure grub
/var/server/grub/grub.cfg
=========================
menuentry 'Windows 10 Installers' {
if [ "$grub_platform" = "efi" ]; then
  echo "UEFI Grub opening ipxe.efi"
  chainloader /ipxe/ipxe.efi

else 
  echo "BIOS Grub opening ipxe.lkrn"
  linux16 /ipxe/ipxe.lkrn
  echo "Opening boot.ipxe"
  initrd16 /ipxe/boot.ipxe
fi  
}

3. Setup IPXE
Download iPXE as in Part 27
$make bin/ipxe.lkrn

4. Create the IPXE config file
/var/server/ipxe/boot.ipxe
==============================
#!ipxe 
echo Starting boot.ipxe
dhcp
echo Booting wimboot
kernel http://192.168.0.1/wimboot/wimboot
initrd /wimboot/bcd BCD
initrd /wimboot/boot.sdi boot.sdi
initrd /winpe/startnet.cmd startnet.cmd
initrd /winpe/wait.cmd wait.cmd
initrd http://192.168.0.1/sources/boot.wim boot.wim
imgstat
boot

5. Startnet.cmd
As per Part 27. Rename startnet_uefi.cmd to startnet.cmd


Part 31 hyper-V Reference Images. Create PXE bootable VM in hyper-V
===================================================================
Using a Linux backend as an alternative to Windows Deployment Server. Configure dhcp to identify a Hyper-V client and provide the correct Msoft boot file.

1. On Windows System Check BIOS for virtualization support
Add Feature Hyper-V in Control Panel, it will be greyed out if System does not support it.

2.Install Windows Server 2019
  https://www.microsoft.com/en-us/evalcenter/download-windows-server-2019
  Download the vhd version

3. Start the VM
  
Add Windows Deployment Services

Get boot files for tftp, copy to server
RRQ from 192.168.0.184 filename hyperv/x64/bootmgfw.efi                         from \Windows\Boot\EFI
RRQ from 192.168.0.184 filename \Boot\boot.sdi                                  from \Windows\Boot\DVD\EFI
RRQ from 192.168.0.184 filename \BCD                                            
RRQ from 192.168.0.184 filename \Boot\BCD                                       from \Windows\Boot\DVD\EFI
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\Policies\SbcpFlightToken.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\SecureBootPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\SkuSiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\SiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\UpdateSkuSiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\UpdateSiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\WinSiPolicy.p7b             from \Windows\Boot\EFI
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\UpdateWinSiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\ATPSiPolicy.p7b
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\UpdateATPSiPolicy.p7b 
RRQ from 192.168.0.184 filename \en-US\hyperv/x64/bootmgfw.efi.MUI
RRQ from 192.168.0.184 filename \hyperv/x64/bootmgfw.efi
RRQ from 192.168.0.184 filename \boot.stl
RRQ from 192.168.0.184 filename \sources\boot.wim                               from 
RRQ from 192.168.0.184 filename \Boot\boot.sdi
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\fonts\segoe_slboot.ttf 
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\fonts\segmono_boot.ttf
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\fonts\wgl4_boot.ttf         from \Windows\Boot\Fonts
RRQ from 192.168.0.184 filename \boot\boot.sdi
RRQ from 192.168.0.184 filename \sources\boot.wim
RRQ from 192.168.0.184 filename \EFI\Microsoft\Boot\Policies\UnlockToken.pol
  

4. Create a Virtual Switch External 

5. Create Legacy Network Adapter on External

6. Create a New Virtual Machine
  Store virtual machine in default location, it's the Virtual Disk that's important
  Generation 2 UEFI
  Memory, not Dynamic or setup may error out with Windows cannot find the Microsoft Software License Terms. 4096Mb
  Checkpoints disabled. Need a clean vhdx file for DISM. If Windows Update fails, re-install previous image and start again
  Networking External (Bridged)
  Create virtual hard disk, Location in User tree, eg Documents\Hyper-V\VMs
  Install Operating System later

7. Modify \sources\boot.wim, unlike other situations startnet.cmd cannot be overwritten
$ sudo apt-get install wimtools
$ mkdir image
$ wimmountrw boot.wim 2 image/

check \windows\system32\startnet.cmd
add \windows\system32\wait.cmd
remove \setup.exe

$ wimunmount image --commit

7. Get the MAC address of the VM

Update /etc/dhcp/dhcpd.conf with logging and first 5 chars of MAC.
  filename "grub/i386-pc/core.0";
  log(info, concat("Vendor Class ID ", substring(option vendor-class-identifier, 15, 5)));
  log(info, concat("Vendor MAC Addr ", binary-to-ascii(16, 8, ":", substring(hardware, 1, 6))));
}

class "win10-x64Pro-tt" {
  match if binary-to-ascii(16, 8, ":", substring(hardware, 1, 5)) = "0:15:5d:1b:39";
    filename "hyperv/x64/bootmgfw.efi";
}

class "UEFI-64-1" {

etc

7. Start VM, it will network boot, start WinPE and run startnet.cmd showing the install menu





Part 32 Reference Images. Create linux based Hyper-V boot server with DHCP and TFTP
===================================================================================
Build a Linux based boot server for Hyper-V PXE clients using DHCP and TFTP.
1. Configure DHCP to boot Hyper-V clients with Msoft's bootmgr EFI file

Update /etc/dhcp/dhcpd.conf with logging and use first 5 chars of MAC to identify Hyper-V clients.

. . . .
  filename "grub/i386-pc/core.0";
  log(info, concat("Vendor Class ID ", substring(option vendor-class-identifier, 15, 5)));
  log(info, concat("Vendor MAC Addr ", binary-to-ascii(16, 8, ":", substring(hardware, 1, 6))));
}

class "hyper-v-1" {
  match if binary-to-ascii(16, 8, ":", substring(hardware, 1, 5)) = "0:15:5d:1b:39";
    filename "hyperv/x64/bootmgfw.efi";
}

class "UEFI-64-1" {

etc

2. Modify \sources\boot.wim with wimtools, unlike booting grub or pxelinux, startnet.cmd cannot be loaded during boot. N.B. Image 2 needs to be updated, video shows 1 in error. This can be done with DISM as shown in Part 28

$ sudo apt-get install wimtools
$ mkdir image
$ wimmountrw boot.wim 2 image/

check \windows\system32\startnet.cmd
add \windows\system32\wait.cmd
remove \setup.exe if necessary

$ wimunmount image --commit

3. Start VM, it will network boot, start WinPE and run startnet.cmd showing the install menu

startnet.cmd and menu.cmd in Part 28




Part 33 Create Virtual Machines as Reference machines, capture wim file with DISM from vhdx file
================================================================================================
Create a capture.cmd to capture and append VHDX files and create an install.wim file. Modified version introduced in Part 1. Uses Production and Development versions of Reference image

1. Create Reference Machines in Hyper-V

1. On Linux System convert the sources share to Writeable in Samba 
This was setup as readonly for guests - unauthenticated users) in Part 28
/etc/samba/smb.conf
....
#======================= Share Definitions =======================
[sources]
  Comment = WinPE Share
  path = /var/server/sources
  read only = yes
  browseable = yes
  guest ok = yes
  write list = user1
  create mask = 0755


Enable Samba user
$ id
uid=1000(user1) gid=1000(user1) groups=1000(user1),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),134(sambashare)

[sudo] password for user1:          
$ sudo smbpasswd -a user1
New SMB password:
Retype new SMB password:
Added user user1.

$ sudo service smbd restart


2. Quiesce System
Make sure Hyper-V is stopped, and turn off Real Time Protection in Windows defender

3. Capture install.wim


Part34 Sanitize New Install
===========================
The new install is a clone of the Reference / Master / Golden image, it has the same computer name which must be changed, any missing drivers installed and must be licenced.

00:00 Win_Info.ps1 startup script
 It's a shortcut, prefix Target with powershell -f, then in Advanced you can select run as administrator.

00:30 Get Asset number

00:00 Rename Computer, this is what needs admin rights

00:00 Check licencing

00:00 Check for missing drivers

00:00 Check Windows Defender (or not)

00:00 Auto delete when completed.

00:00 Gotchas in the Hyper-V Reference Image process

Install django
==============

00:00 install Pycharm
https://www.jetbrains.com/pycharm/download/#section=linux

cp Downloads/pycharm-community-2023.1.1.tar.gz .local/bin/



sudo  apt-get install grub
Reading package lists... Done
Building dependency tree       
Reading state information... Done
Package grub is not available, but is referred to by another package.
This may mean that the package is missing, has been obsoleted, or
is only available from another source
However the following packages replace it:
  grub-efi-amd64:i386 grub2-common grub-pc grub-efi-ia32 grub-efi-amd64

grub-mkimage --version
grub-mkimage (GRUB) 2.04-1ubuntu26.16


git clone http://git.savannah.gnu.org/git/grub.git

sudo apt-get install gnulib


line 50 of bootstrap
default_gnulib_url=http://git.savannah.gnu.org/git/gnulib.git


./bootstrap

./configure

make

sudo grub-mkimage -O i386-pc-pxe \
    --output /var/server/grub/i386-pc/core.0 \
    --prefix=grub \
    -c grub-build.conf \
    -d grub-core/  \
  pxe tftp 



